One-Upper: Fixed 21-Show Rivalry Implementation - COMPLETE MERGED SPEC
Session Date: November 23, 2024
Ready for immediate implementation - All decisions + All code

EXECUTIVE SUMMARY
Current State: One-Upper is production-ready at oneupper.app with infinite rivalries. All features work (AI judging, real-time sync, artifacts, brain boosts, Ripley emcee).
Goal: Convert from infinite rivalries to fixed 21-show matches with AI-generated summary and clean ending.
Why 21: Odd number guarantees winner (no W/L ties), "best of 21" is culturally resonant, creates clear goal and shareable moment.
Timeline: 2-3 days for core implementation
Critical: We found and fixed race condition bug in judging trigger (Screen4.jsx lines 475-530) - now checks database state AFTER update instead of stale local state.

KEY DECISIONS CONFIRMED

Rivalry length: 21 shows (odd number, no ties)
Show numbering: Display "Show X/21" throughout
After show 21: AI summary screen, rivalry marked status='complete'
Cancelled rivalries: Status set to 'cancelled' (preserve data, not delete)
Summary retry limit: 3 attempts max (prevent runaway AI costs)
Tie handling: Use total points as tiebreaker. If STILL tied (extremely unlikely), show 21 winner breaks tie.
Opponent code on summary: No - keep summary screen simple
Existing test rivalries: Let them naturally convert to 21-show limit
Share button: Stub it in as placeholder (simple copy text for now)
Cancel rivalry: Keep in menu with updated warning text
Use constants: RIVALRY_LENGTH = 21 for easy future changes


PHASE 1: DATABASE SCHEMA UPDATES
SQL Migration Script
Run these statements in Supabase SQL Editor:
sql-- Add new columns to rivalries table
ALTER TABLE rivalries 
ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'active',
ADD COLUMN IF NOT EXISTS summary TEXT,
ADD COLUMN IF NOT EXISTS ended_at TIMESTAMP;

-- Optional: Add match_length for future flexibility
ALTER TABLE rivalries 
ADD COLUMN IF NOT EXISTS match_length INTEGER DEFAULT 21;

-- Add check constraint for status values
ALTER TABLE rivalries 
ADD CONSTRAINT rivalries_status_check 
CHECK (status IN ('active', 'complete', 'cancelled'));

-- Update existing rivalries to have status='active'
UPDATE rivalries 
SET status = 'active' 
WHERE status IS NULL;

-- Add index for querying completed rivalries
CREATE INDEX IF NOT EXISTS idx_rivalries_status ON rivalries(status);
CREATE INDEX IF NOT EXISTS idx_rivalries_ended_at ON rivalries(ended_at) WHERE status = 'complete';
No changes needed to shows table - already has show_number field scoped to rivalry_id.

PHASE 2: RIPLEY END-GAME LINES
Add to emcee_lines Table
sql-- Show 19 (3 shows remaining)
INSERT INTO emcee_lines (trigger_type, condition, text, weight) VALUES
('show_transition', 'show_19', 'Show 19. Three to go. Still anyone''s game.', 10),
('show_transition', 'show_19', 'Three shows left. Make every answer count now.', 10),
('show_transition', 'show_19', 'Show 19 of 21. The pressure''s building.', 10),
('show_transition', 'show_19', 'Getting close now. {player1} leads {score}.', 8);

-- Show 20 (2 shows remaining - penultimate)
INSERT INTO emcee_lines (trigger_type, condition, text, weight) VALUES
('show_transition', 'show_20', 'Show 20. Two shows to go. This is heating up.', 10),
('show_transition', 'show_20', 'Penultimate round. {player1} leads {score}. Can {player2} catch up?', 10),
('show_transition', 'show_20', 'One more after this. Everything''s on the line.', 10),
('show_transition', 'show_20', 'Show 20 of 21. The end is near.', 8);

-- Show 21 (FINALE - highest weight)
INSERT INTO emcee_lines (trigger_type, condition, text, weight) VALUES
('show_transition', 'show_21', 'This is it. Show 21. The finale. Winner takes all.', 15),
('show_transition', 'show_21', 'Final show. One answer decides the mic holder. No pressure.', 15),
('show_transition', 'show_21', 'Show 21. Everything comes down to this. Let''s see what you got.', 15),
('show_transition', 'show_21', 'The last call. Score''s {score}. Time to prove who''s funnier.', 12),
('show_transition', 'show_21', 'Twenty-one shows. It all ends here. Make it count.', 12);
Update select-emcee-line Edge Function
In /supabase/functions/select-emcee-line/index.ts, add show number detection:
typescript// Around line 50-80 where condition is determined
let condition = 'any';

// Detect specific show numbers for special lines
if (showNumber === 19) {
  condition = 'show_19';
} else if (showNumber === 20) {
  condition = 'show_20';
} else if (showNumber === 21) {
  condition = 'show_21';
} else if (showNumber === 5 || showNumber === 10) {
  condition = 'milestone';
} else if (isTiedGame) {
  condition = 'tied_game';
} else if (isCloseGame) {
  condition = 'close_game';
}
// ... rest of logic
Redeploy after changes:
bashsupabase functions deploy select-emcee-line

PHASE 3: NEW COMPONENT - RivalrySummaryScreen.jsx
Complete Component Code
Location: src/components/RivalrySummaryScreen.jsx
jsximport { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase';
import Header from './Header';

const RIVALRY_LENGTH = 21; // Constant for easy future changes

export default function RivalrySummaryScreen({ rivalryId, onNavigate, activeProfileId }) {
  const [loading, setLoading] = useState(true);
  const [summary, setSummary] = useState(null);
  const [rivalry, setRivalry] = useState(null);
  const [error, setError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);
  const [isRetrying, setIsRetrying] = useState(false);

  useEffect(() => {
    loadSummary();
  }, []);

  async function loadSummary() {
    try {
      // Fetch rivalry with player profiles
      const { data: rivalryData, error: rivalryError } = await supabase
        .from('rivalries')
        .select(`
          *,
          profile_a:profiles!rivalries_profile_a_id_fkey(id, name, avatar, code),
          profile_b:profiles!rivalries_profile_b_id_fkey(id, name, avatar, code)
        `)
        .eq('id', rivalryId)
        .single();
      
      if (rivalryError) throw rivalryError;
      
      setRivalry(rivalryData);
      
      // If summary already exists, use it
      if (rivalryData.summary) {
        const parsedSummary = typeof rivalryData.summary === 'string' 
          ? JSON.parse(rivalryData.summary) 
          : rivalryData.summary;
        setSummary(parsedSummary);
        setLoading(false);
      } else {
        // Generate new summary
        await generateSummary();
      }
    } catch (err) {
      console.error('Failed to load summary:', err);
      setError('Failed to load rivalry data');
      setLoading(false);
    }
  }

  async function generateSummary() {
    try {
      setIsRetrying(true);
      
      const { data, error } = await supabase.functions.invoke('summarize-rivalry', {
        body: { rivalryId }
      });
      
      if (error) throw error;
      
      setSummary(data);
      setLoading(false);
      setIsRetrying(false);
      setError(null);
    } catch (err) {
      console.error('Failed to generate summary:', err);
      setError('Failed to generate AI summary. Please try again.');
      setLoading(false);
      setIsRetrying(false);
    }
  }

  async function handleRetry() {
    if (retryCount >= 3) {
      setError('Maximum retry attempts reached. Please contact support.');
      return;
    }
    
    setRetryCount(prev => prev + 1);
    setError(null);
    setLoading(true);
    await generateSummary();
  }

  function handleChallengeNewFriend() {
    // Navigate back to Screen1
    onNavigate('screen1');
  }

  function handleShareSummary() {
    // Simple text copy for now (stub for future image generation)
    if (!summary || !rivalry) return;
    
    const myProfile = rivalry.profile_a_id === activeProfileId ? rivalry.profile_a : rivalry.profile_b;
    const opponentProfile = rivalry.profile_a_id === activeProfileId ? rivalry.profile_b : rivalry.profile_a;
    const myWins = rivalry.profile_a_id === activeProfileId 
      ? summary.final_score.player_a_wins 
      : summary.final_score.player_b_wins;
    const opponentWins = rivalry.profile_a_id === activeProfileId 
      ? summary.final_score.player_b_wins 
      : summary.final_score.player_a_wins;
    
    const shareText = `I just ${myWins > opponentWins ? 'beat' : 'lost to'} ${opponentProfile.name} ${myWins}-${opponentWins} in a 21-show One-Upper rivalry! üé§\n\nChallenge me: oneupper.app`;
    
    navigator.clipboard.writeText(shareText).then(() => {
      alert('Summary copied to clipboard!');
    }).catch(err => {
      console.error('Failed to copy:', err);
      alert('Failed to copy summary');
    });
  }

  // Loading state
  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 flex items-center justify-center p-4">
        <div className="text-center">
          <div className="text-orange-500 text-2xl mb-4 animate-pulse">
            ‚ú® Generating rivalry summary...
          </div>
          <div className="text-slate-400 text-sm">
            Analyzing {RIVALRY_LENGTH} shows of creative brilliance
          </div>
        </div>
      </div>
    );
  }

  // Error state
  if (error && !summary) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 p-4">
        <Header />
        <div className="max-w-2xl mx-auto mt-8">
          <div className="bg-slate-800 border-2 border-red-500/50 rounded-lg p-6 mb-6">
            <div className="text-red-400 text-center mb-4">
              <div className="text-4xl mb-2">‚ö†Ô∏è</div>
              <div className="font-semibold mb-2">Error Generating Summary</div>
              <div className="text-sm text-slate-300">{error}</div>
            </div>
            
            {retryCount < 3 && (
              <button 
                onClick={handleRetry}
                disabled={isRetrying}
                className="w-full px-4 py-3 bg-orange-500 text-white rounded-lg hover:bg-orange-400 transition-all font-semibold disabled:bg-slate-600 disabled:cursor-not-allowed mb-3"
              >
                {isRetrying ? 'Retrying...' : `Retry (${retryCount}/3 attempts)`}
              </button>
            )}
            
            <button 
              onClick={handleChallengeNewFriend}
              className="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-slate-200 rounded-lg hover:bg-slate-600 transition-all font-semibold"
            >
              Back to Home
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Main summary display
  if (!summary || !rivalry) return null;

  const didIWin = rivalry.mic_holder_id === activeProfileId;
  const myProfile = rivalry.profile_a_id === activeProfileId ? rivalry.profile_a : rivalry.profile_b;
  const opponentProfile = rivalry.profile_a_id === activeProfileId ? rivalry.profile_b : rivalry.profile_a;
  
  const myWins = rivalry.profile_a_id === activeProfileId 
    ? summary.final_score.player_a_wins 
    : summary.final_score.player_b_wins;
  const opponentWins = rivalry.profile_a_id === activeProfileId 
    ? summary.final_score.player_b_wins 
    : summary.final_score.player_a_wins;

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 p-4 pb-24">
      <Header />
      
      <div className="max-w-2xl mx-auto mt-6">
        
        {/* Header */}
        <div className="text-center mb-6">
          <h1 className="text-3xl font-bold text-slate-100 mb-2">
            {didIWin ? 'üéâ Victory!' : 'üí™ Nice Effort!'}
          </h1>
          <div className="text-xl text-slate-300 mb-4">
            Rivalry Complete
          </div>
          
          {/* Final Score Card */}
          <div className="bg-slate-800/50 border border-slate-600 rounded-lg p-6 mb-6">
            <div className="flex items-center justify-center gap-4 mb-4">
              <div className="text-center">
                <div className="text-3xl mb-1">{myProfile.avatar}</div>
                <div className="text-slate-300 text-sm font-semibold">{myProfile.name}</div>
              </div>
              
              <div className="text-center">
                <div className="text-5xl font-bold text-slate-100">
                  {myWins} <span className="text-slate-600">-</span> {opponentWins}
                </div>
              </div>
              
              <div className="text-center">
                <div className="text-3xl mb-1">{opponentProfile.avatar}</div>
                <div className="text-slate-300 text-sm font-semibold">{opponentProfile.name}</div>
              </div>
            </div>
            
            <div className="text-orange-500 font-semibold text-lg">
              üé§ {didIWin ? "You're" : `${opponentProfile.name} is`} the Mic Holder
            </div>
          </div>
        </div>

        {/* AI Summary */}
        <div className="bg-slate-800/50 border border-slate-600 rounded-lg p-6 mb-6">
          <h2 className="text-lg font-bold text-orange-500 mb-4 flex items-center gap-2">
            <span>üìä</span>
            <span>Rivalry Recap</span>
          </h2>
          <div className="text-slate-200 text-sm leading-relaxed space-y-3">
            {summary.analysis.split('\n\n').map((paragraph, idx) => (
              <p key={idx}>{paragraph}</p>
            ))}
          </div>
        </div>

        {/* Stats */}
        {summary.stats && (
          <div className="bg-slate-800/50 border border-slate-600 rounded-lg p-6 mb-6">
            <h2 className="text-lg font-bold text-orange-500 mb-4 flex items-center gap-2">
              <span>üèÜ</span>
              <span>Notable Moments</span>
            </h2>
            <div className="space-y-4">
              {/* Closest Show */}
              {summary.stats.closest_show && (
                <div className="flex items-start gap-3">
                  <span className="text-2xl">üî•</span>
                  <div>
                    <div className="text-slate-300 text-sm font-semibold">Closest Show</div>
                    <div className="text-slate-400 text-xs">
                      Show {summary.stats.closest_show.show_num} ({summary.stats.closest_show.diff} point difference)
                    </div>
                  </div>
                </div>
              )}
              
              {/* Biggest Blowout */}
              {summary.stats.biggest_blowout && (
                <div className="flex items-start gap-3">
                  <span className="text-2xl">üí•</span>
                  <div>
                    <div className="text-slate-300 text-sm font-semibold">Biggest Blowout</div>
                    <div className="text-slate-400 text-xs">
                      Show {summary.stats.biggest_blowout.show_num} ({summary.stats.biggest_blowout.diff} point margin)
                    </div>
                  </div>
                </div>
              )}

              {/* Judge Favorites */}
              {summary.stats.player_a_best_judge && summary.stats.player_b_best_judge && (
                <div className="flex items-start gap-3">
                  <span className="text-2xl">‚öñÔ∏è</span>
                  <div>
                    <div className="text-slate-300 text-sm font-semibold">Judge Favorites</div>
                    <div className="text-slate-400 text-xs">
                      {myProfile.name}: {rivalry.profile_a_id === activeProfileId 
                        ? summary.stats.player_a_best_judge.name 
                        : summary.stats.player_b_best_judge.name} 
                      ({(rivalry.profile_a_id === activeProfileId 
                        ? summary.stats.player_a_best_judge.avg 
                        : summary.stats.player_b_best_judge.avg).toFixed(1)} avg)
                      <br />
                      {opponentProfile.name}: {rivalry.profile_a_id === activeProfileId 
                        ? summary.stats.player_b_best_judge.name 
                        : summary.stats.player_a_best_judge.name} 
                      ({(rivalry.profile_a_id === activeProfileId 
                        ? summary.stats.player_b_best_judge.avg 
                        : summary.stats.player_a_best_judge.avg).toFixed(1)} avg)
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Action Buttons */}
        <div className="space-y-3">
          <button
            onClick={handleShareSummary}
            className="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-slate-200 rounded-lg hover:bg-slate-600 transition-all font-semibold"
          >
            üìã Share Summary
          </button>
          
          <button
            onClick={handleChallengeNewFriend}
            className="w-full px-4 py-3 bg-orange-500 text-white rounded-lg hover:bg-orange-400 transition-all font-semibold"
          >
            Challenge a Friend
          </button>
        </div>

        {/* Optional: Opponent code for rematch */}
        {opponentProfile.code && (
          <div className="text-center text-sm text-slate-400 mt-6 pt-6 border-t border-slate-700">
            <div className="mb-2">Want a rematch with {opponentProfile.name}?</div>
            <div className="bg-slate-800 border border-slate-600 rounded p-3 inline-block">
              <div className="text-xs text-slate-500 mb-1">Their code:</div>
              <div className="text-orange-500 font-mono text-base font-semibold">
                {opponentProfile.code}
              </div>
            </div>
            <button 
              onClick={() => {
                navigator.clipboard.writeText(opponentProfile.code);
                alert('Code copied to clipboard!');
              }}
              className="block mx-auto mt-2 text-xs text-orange-500 hover:text-orange-400 transition-colors"
            >
              Copy Code
            </button>
          </div>
        )}

      </div>
    </div>
  );
}

PHASE 4: NEW EDGE FUNCTION - summarize-rivalry
Complete Edge Function Code
Location: supabase/functions/summarize-rivalry/index.ts
typescriptimport { createClient } from '@supabase/supabase-js';

const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const anthropicKey = Deno.env.get('ANTHROPIC_API_KEY')!;

const RIVALRY_LENGTH = 21;

interface Show {
  id: string;
  show_number: number;
  prompt: string;
  profile_a_answer: string;
  profile_b_answer: string;
  winner_id: string;
  judge_data: any;
}

Deno.serve(async (req) => {
  // CORS headers
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST',
        'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
      }
    });
  }

  try {
    const { rivalryId } = await req.json();
    
    if (!rivalryId) {
      return new Response(JSON.stringify({ error: 'rivalryId is required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
      });
    }
    
    const supabase = createClient(supabaseUrl, supabaseKey);
    
    // 1. Fetch rivalry with player names
    const { data: rivalry, error: rivalryError } = await supabase
      .from('rivalries')
      .select(`
        *,
        profile_a:profiles!rivalries_profile_a_id_fkey(id, name, avatar),
        profile_b:profiles!rivalries_profile_b_id_fkey(id, name, avatar)
      `)
      .eq('id', rivalryId)
      .single();
    
    if (rivalryError || !rivalry) {
      return new Response(JSON.stringify({ error: 'Rivalry not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
      });
    }
    
    // Check if summary already exists (idempotency)
    if (rivalry.summary) {
      const existingSummary = typeof rivalry.summary === 'string' 
        ? JSON.parse(rivalry.summary) 
        : rivalry.summary;
      
      return new Response(JSON.stringify(existingSummary), {
        headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
      });
    }
    
    // 2. Fetch all shows for this rivalry
    const { data: shows, error: showsError } = await supabase
      .from('shows')
      .select('*')
      .eq('rivalry_id', rivalryId)
      .order('show_number', { ascending: true });
    
    if (showsError || !shows || shows.length === 0) {
      return new Response(JSON.stringify({ error: 'No shows found for rivalry' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
      });
    }
    
    // 3. Calculate comprehensive stats
    const playerA = rivalry.profile_a;
    const playerB = rivalry.profile_b;
    
    let playerAWins = 0;
    let playerBWins = 0;
    let playerATotalPoints = 0;
    let playerBTotalPoints = 0;
    
    let closestShow = { show_num: 0, diff: Infinity };
    let biggestBlowout = { show_num: 0, diff: 0, winner: '' };
    
    const judgeScores: {
      playerA: Record<string, number[]>;
      playerB: Record<string, number[]>;
    } = {
      playerA: {},
      playerB: {}
    };
    
    shows.forEach((show: Show) => {
      // Count wins
      if (show.winner_id === playerA.id) playerAWins++;
      if (show.winner_id === playerB.id) playerBWins++;
      
      // Calculate scores
      const scores = show.judge_data?.scores || {};
      let playerAShowTotal = 0;
      let playerBShowTotal = 0;
      
      Object.entries(scores).forEach(([judgeName, judgeScore]: [string, any]) => {
        const scoreA = judgeScore.profile_a_score || 0;
        const scoreB = judgeScore.profile_b_score || 0;
        
        playerAShowTotal += scoreA;
        playerBShowTotal += scoreB;
        
        playerATotalPoints += scoreA;
        playerBTotalPoints += scoreB;
        
        // Track judge scores for favorites calculation
        if (!judgeScores.playerA[judgeName]) judgeScores.playerA[judgeName] = [];
        if (!judgeScores.playerB[judgeName]) judgeScores.playerB[judgeName] = [];
        
        judgeScores.playerA[judgeName].push(scoreA);
        judgeScores.playerB[judgeName].push(scoreB);
      });
      
      const diff = Math.abs(playerAShowTotal - playerBShowTotal);
      
      // Track closest show
      if (diff < closestShow.diff) {
        closestShow = { show_num: show.show_number, diff };
      }
      
      // Track biggest blowout
      if (diff > biggestBlowout.diff) {
        biggestBlowout = {
          show_num: show.show_number,
          diff,
          winner: playerAShowTotal > playerBShowTotal ? playerA.name : playerB.name
        };
      }
    });
    
    // Determine winner using tiebreaker rules
    let winnerId: string;
    let winnerName: string;
    
    if (playerAWins > playerBWins) {
      winnerId = playerA.id;
      winnerName = playerA.name;
    } else if (playerBWins > playerAWins) {
      winnerId = playerB.id;
      winnerName = playerB.name;
    } else {
      // W/L tie - use total points
      if (playerATotalPoints > playerBTotalPoints) {
        winnerId = playerA.id;
        winnerName = playerA.name;
      } else if (playerBTotalPoints > playerATotalPoints) {
        winnerId = playerB.id;
        winnerName = playerB.name;
      } else {
        // Total points ALSO tied (extremely unlikely) - use show 21 winner
        const show21 = shows.find((s: Show) => s.show_number === 21);
        winnerId = show21?.winner_id || playerA.id;
        winnerName = winnerId === playerA.id ? playerA.name : playerB.name;
      }
    }
    
    // Calculate judge averages
    const calculateAvg = (scores: number[]) => 
      scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
    
    const playerAJudgeAvgs = Object.entries(judgeScores.playerA)
      .map(([judge, scores]) => ({
        judge,
        avg: calculateAvg(scores)
      }))
      .sort((a, b) => b.avg - a.avg);
    
    const playerBJudgeAvgs = Object.entries(judgeScores.playerB)
      .map(([judge, scores]) => ({
        judge,
        avg: calculateAvg(scores)
      }))
      .sort((a, b) => b.avg - a.avg);
    
    const playerABestJudge = playerAJudgeAvgs[0] || { judge: 'unknown', avg: 0 };
    const playerBBestJudge = playerBJudgeAvgs[0] || { judge: 'unknown', avg: 0 };
    
    // 4. Build AI prompt with all show data
    const showsContext = shows.map((show: Show) => {
      const scores = show.judge_data?.scores || {};
      const judgeComments = Object.values(scores)
        .map((s: any) => `${s.comment || ''}`)
        .filter(c => c)
        .join(' | ');
      
      return `Show ${show.show_number}: "${show.prompt}"
- ${playerA.name}: "${show.profile_a_answer}"
- ${playerB.name}: "${show.profile_b_answer}"
- Winner: ${show.winner_id === playerA.id ? playerA.name : playerB.name}
- Judge reactions: ${judgeComments}`;
    }).join('\n\n');
    
    const prompt = `You are analyzing a completed 21-show comedy rivalry between two players.

PLAYERS:
- Player A: ${playerA.name}
- Player B: ${playerB.name}

FINAL SCORE:
${playerA.name}: ${playerAWins} wins (${playerATotalPoints} total points)
${playerB.name}: ${playerBWins} wins (${playerBTotalPoints} total points)
Winner: ${winnerName}

ALL ${shows.length} SHOWS:
${showsContext}

STATS:
- Closest show: #${closestShow.show_num} (${closestShow.diff} point difference)
- Biggest blowout: #${biggestBlowout.show_num} (${biggestBlowout.diff} point margin, won by ${biggestBlowout.winner})
- ${playerA.name}'s best judge: ${playerABestJudge.judge} (${playerABestJudge.avg.toFixed(1)} avg score)
- ${playerB.name}'s best judge: ${playerBBestJudge.judge} (${playerBBestJudge.avg.toFixed(1)} avg score)

YOUR TASK:
Write a 3-4 paragraph analysis of this rivalry. Be specific, insightful, and entertaining.

Cover:
1. **Playing Styles**: How did each player approach the prompts? Who took risks vs. played it safe? Did they evolve over 21 shows?
2. **Competitive Arc**: How did the rivalry evolve? Any momentum shifts, comebacks, or turning points? Reference specific show numbers.
3. **Judge Dynamics**: Which judges favored which player and why? Were there consistent patterns in scoring?
4. **What Made It Special**: What defined this rivalry? What will be remembered?

TONE: Sports analyst meets comedy critic. Be honest, specific, and engaging.

CRITICAL RULES:
- Use player names (${playerA.name}, ${playerB.name}), NEVER "Player A/B"
- Reference specific show numbers as examples (e.g., "Show 7 was the turning point...")
- Be SPECIFIC, not generic ("Both players were creative" = useless)
- Every sentence should add value and insight
- Write in natural paragraphs separated by \\n\\n

OUTPUT FORMAT: Just the analysis text (3-4 paragraphs). No JSON, no headers, no formatting. Raw text only.`;

    // 5. Call Claude API
    const anthropicResponse = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': anthropicKey,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 2000,
        messages: [{
          role: 'user',
          content: prompt
        }]
      })
    });
    
    if (!anthropicResponse.ok) {
      throw new Error(`Anthropic API error: ${anthropicResponse.status}`);
    }
    
    const anthropicData = await anthropicResponse.json();
    const analysis = anthropicData.content[0].text;
    
    // 6. Build response object
    const summaryData = {
      final_score: {
        player_a_wins: playerAWins,
        player_b_wins: playerBWins,
        player_a_name: playerA.name,
        player_b_name: playerB.name,
        player_a_total_points: playerATotalPoints,
        player_b_total_points: playerBTotalPoints
      },
      analysis: analysis.trim(),
      stats: {
        closest_show: closestShow,
        biggest_blowout: biggestBlowout,
        player_a_best_judge: { name: playerABestJudge.judge, avg: playerABestJudge.avg },
        player_b_best_judge: { name: playerBBestJudge.judge, avg: playerBBestJudge.avg }
      }
    };
    
    // 7. Save to database
    const { error: updateError } = await supabase
      .from('rivalries')
      .update({
        summary: JSON.stringify(summaryData),
        status: 'complete',
        ended_at: new Date().toISOString(),
        mic_holder_id: winnerId
      })
      .eq('id', rivalryId);
    
    if (updateError) {
      console.error('Failed to save summary to database:', updateError);
      // Continue anyway - return summary even if save fails
    }
    
    // 8. Return
    return new Response(JSON.stringify(summaryData), {
      headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
    });
    
  } catch (error) {
    console.error('Error in summarize-rivalry:', error);
    return new Response(JSON.stringify({ 
      error: error.message || 'Internal server error'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
    });
  }
});
Deploy command:
bashsupabase functions deploy summarize-rivalry

PHASE 5: MODIFY SCREEN4.JSX
Changes Needed
IMPORTANT: Use the FIXED version from /mnt/user-data/outputs/Screen4.jsx which has the race condition bug fix.
Change 1: Add constant at top (after imports)
javascriptconst RIVALRY_LENGTH = 21;
Change 2: Add state for summary screen
javascriptconst [showRivalrySummary, setShowRivalrySummary] = useState(false);
Change 3: Update show number display (find all instances)
Find: Show {currentShow.show_number}
Replace with: Show {currentShow.show_number}/{RIVALRY_LENGTH}
Locations:

Header display (~line 1000-1100)
Any other show number displays

Change 4: Check for show 21 completion in verdict useEffect
Find the useEffect that handles verdict display (around line 380-400) and add:
javascriptuseEffect(() => {
  // Existing verdict declaration logic...
  
  // NEW: Check if show 21 just completed
  if (currentShow?.status === 'complete' && currentShow.show_number === RIVALRY_LENGTH) {
    setShowRivalrySummary(true);
  }
}, [currentShow?.status, currentShow?.show_number, currentShow?.id]);
Change 5: Block show 22 creation in createNextShow
At the start of createNextShow function (around line 644), add:
javascriptasync function createNextShow() {
  // Block creation after final show
  if (currentShow.show_number >= RIVALRY_LENGTH) {
    console.log('Rivalry complete - no more shows');
    return;
  }
  
  // ... rest of existing logic
}
Change 6: Conditional render for summary screen
In the main render, before returning Screen4 content, add:
javascript// If rivalry complete, show summary instead
if (showRivalrySummary) {
  return (
    <RivalrySummaryScreen 
      rivalryId={rivalryId}
      onNavigate={onNavigate}
      activeProfileId={activeProfileId}
    />
  );
}
Change 7: Hide Next Show button after show 21
In verdict display section (around line 1450-1500), wrap "Next Show" buttons:
javascript{currentShow.show_number < RIVALRY_LENGTH && (
  // Existing Next Show button code
  <button onClick={createNextShow}>
    {countdown !== null ? `NEXT SHOW (${countdown})` : 'NEXT SHOW'}
  </button>
)}
Change 8: Import RivalrySummaryScreen at top
javascriptimport RivalrySummaryScreen from './RivalrySummaryScreen';
Change 9: Update Cancel Rivalry modal text
Find cancel rivalry modal (around line 800-850), update text:
javascript<p className="text-slate-300 mb-6">
  Are you sure you want to cancel this rivalry? You're currently on 
  show {currentShow.show_number} of {RIVALRY_LENGTH}. Canceling will end 
  the rivalry immediately without generating a summary.
</p>

PHASE 6: MODIFY OTHER COMPONENTS
Screen6.jsx (Show History Detail)
Change: Update show number display
Find: Show {show.show_number}
Replace: Show {show.show_number}/21
Location: Header section (~line 50-100)

InterstitialScreen.jsx (Ripley Interstitials)
Change: Update show number display if present
Find any: Show {showNumber}
Replace: Show {showNumber}/21

HowToPlayModal.jsx
Add section explaining 21-show format
Find the appropriate section (after game rules, before Pro Tips) and add:
jsx<div className="mb-4">
  <h3 className="font-semibold text-slate-200 mb-2 flex items-center gap-2">
    <span>üìä</span>
    <span>The 21-Show Format</span>
  </h3>
  <p className="text-sm text-slate-300 leading-relaxed">
    Each rivalry is exactly 21 shows. After show 21, an AI generates 
    a comprehensive analysis of your rivalry, declares the mic holder, 
    and celebrates your creative battle. Challenge the same friend again 
    for a rematch, or start fresh with someone new.
  </p>
</div>

Landing Page / index.html
Update hero section:
html<h1>Challenge Your Friend to the Best of 21</h1>
<p class="tagline">
  21 shows. AI judges. One mic holder.
</p>
<p class="description">
  Prove who's funnier in escalating creative battles. 
  Each rivalry is 21 shows. After the finale, an AI analyzes 
  your entire rivalry and declares the winner. Can you claim 
  the mic holder crown?
</p>

DEPLOYMENT SEQUENCE
Step 1: Database Migration
bash# In Supabase SQL Editor, run all Phase 1 SQL statements
Step 2: Deploy Edge Functions
bash# Deploy updated select-emcee-line (if modified)
supabase functions deploy select-emcee-line

# Deploy new summarize-rivalry
supabase functions deploy summarize-rivalry
Step 3: Frontend Code
bash# Commit all changes
git add .
git commit -m "feat: implement fixed 21-show rivalries with AI summary"

# Push to trigger Vercel deployment
git push origin main
Step 4: Verify Deployment

Check Vercel deployment succeeds
Test on production URL
Monitor Edge Function logs in Supabase


TESTING CHECKLIST
Critical Tests (Do These First)
Test 1: Complete 21-Show Rivalry

 Create rivalry between two test profiles
 Play all 21 shows (use simple answers to speed up)
 Verify show numbering throughout: "Show X/21"
 Verify Ripley lines at shows 19, 20, 21
 After show 21 verdict, verify summary screen appears
 Verify AI summary text displays (3-4 paragraphs)
 Verify stats are accurate (closest, biggest, judge favs)
 Verify final score matches actual W/L
 Verify correct mic holder declared
 Click "Challenge a Friend" - returns to Screen1
 Check database: rivalry status='complete', summary saved

Test 2: Show 22 is Blocked

 After show 21 summary, no "Next Show" option visible
 Try to create show 22 (should be impossible)

Test 3: New Rivalry Same Players

 Complete 21-show rivalry
 Create NEW rivalry (same two players)
 Verify new rivalry_id created
 Verify first show is "Show 1/21"
 Old rivalry remains in database as 'complete'

Test 4: Summary Generation Failure

 Temporarily break Anthropic API key
 Complete show 21
 Verify error message appears
 Verify retry button works
 Verify max 3 retries enforced
 Restore API key, retry successfully

Test 5: Mid-Rivalry Cancel

 Start rivalry, play to show 10
 Cancel from menu
 Verify warning mentions "show 10 of 21"
 Confirm cancel
 Verify status='cancelled' in database
 Verify no summary generated

Edge Cases
Test 6: Tie Scenarios

 Manually create show data with 10-10 W/L record going into show 21
 Play show 21, verify winner determined
 Check summary mentions close rivalry

Test 7: Browser Interruptions

 Complete show 21, summary loading
 Close browser mid-generation
 Reload game
 Verify summary either re-fetches or regenerates
 Verify no duplicate summaries created

Test 8: Both Players Complete Simultaneously

 Two browser windows, both at show 21 verdict
 Both click through to summary at same time
 Verify only one summary generated (idempotency)
 Both see same summary

Database Verification
After completing test rivalry:
sql-- Check rivalry record
SELECT id, status, ended_at, summary, mic_holder_id
FROM rivalries 
WHERE id = 'TEST_RIVALRY_ID';

-- Should show:
-- status: 'complete'
-- ended_at: timestamp
-- summary: JSON string with analysis
-- mic_holder_id: winner's profile id

-- Verify all 21 shows exist
SELECT show_number, winner_id, status
FROM shows 
WHERE rivalry_id = 'TEST_RIVALRY_ID'
ORDER BY show_number;

-- Should return exactly 21 rows, all status='complete'

-- Verify no show 22 exists
SELECT COUNT(*) FROM shows 
WHERE rivalry_id = 'TEST_RIVALRY_ID' 
AND show_number > 21;

-- Should return 0

ERROR HANDLING & EDGE CASES
Summary Generation Failures
Scenario: Anthropic API times out or errors
Handling in Edge Function:

30 second timeout
Return error object with message
Don't update rivalry status on failure

Handling in Frontend:

Display error message
Show retry button
Track retry count (max 3)
Allow user to skip to home if all retries fail


Race Condition: Both Players Trigger Summary
Scenario: Both players complete show 21 simultaneously
Solution in Edge Function:
typescript// Check if summary already exists (idempotency)
if (rivalry.summary) {
  return JSON.parse(rivalry.summary); // Return cached
}
This prevents duplicate AI calls and ensures both players see same summary.

Extremely Unlikely Tie
Scenario: W/L tied 10-11, total points ALSO tied
Solution in Edge Function:
typescriptif (playerAWins === playerBWins) {
  // Use total points
  if (playerATotalPoints > playerBTotalPoints) {
    winner = playerA;
  } else if (playerBTotalPoints > playerATotalPoints) {
    winner = playerB;
  } else {
    // Both tied - use show 21 winner
    const show21 = shows.find(s => s.show_number === 21);
    winner = show21.winner_id === playerA.id ? playerA : playerB;
  }
}

User Closes Browser During Summary
Scenario: Summary screen loading, user closes tab
Solution:

On component mount, check if rivalry.summary exists
If yes: parse and display
If no: generate new summary
This makes reloads safe


COST ANALYSIS
Per Rivalry (21 shows)

AI Judging: 21 shows √ó $0.015 = ~$0.32
AI Summary: 1 call √ó $0.06 = ~$0.06
Emcee Lines: 21 shows √ó <$0.001 = ~$0.02
Total per rivalry: ~$0.40

At Scale (1000 rivalries/month)

Monthly cost: ~$400
Per user (if 2000 users): $0.20/month
Acceptable for growth phase


SUCCESS METRICS TO TRACK
After launch, monitor:

Completion rate: % of started rivalries that reach show 21

Target: 50%+ completion rate


Time to complete: Average days to finish 21 shows

Target: <7 days average


Summary engagement: Time spent on summary screen

Target: 30+ seconds average dwell time


Share rate: % who click "Share Summary"

Target: 20%+ share rate


Rematch rate: % who challenge same opponent again

Target: 10%+ rematch rate


Drop-off points: Which show numbers have highest abandonment

Identify: If drop-off spikes at certain shows, investigate why




FUTURE FLEXIBILITY PRESERVED
This implementation enables future features:
‚úÖ Change rivalry length: Just update RIVALRY_LENGTH constant
‚úÖ Add seasons: Each 21 shows = season, then Season 2, 3, etc.
‚úÖ Match types: Quick (7), Standard (21), Marathon (50)
‚úÖ Concurrent rivalries: Remove unique constraint
‚úÖ Rivalry history UI: Data preserved with status='complete'
‚úÖ Leaderboards: Query across completed rivalries
‚úÖ Rematch system: Clean endings enable clean restarts
Optional database enhancement for variable lengths:
sqlALTER TABLE rivalries ADD COLUMN match_length INTEGER DEFAULT 21;
```

---

## CRITICAL BUG FIX INCLUDED

**Bug:** Race condition causing stuck "waiting" state when both players submit simultaneously.

**Location:** Screen4.jsx handleSubmit function

**Problem:** Checked stale local state instead of database state after update.

**Fix:** Now uses `.select().single()` to get fresh data after update, then checks if both answers present.

**Status:** Already fixed in `/mnt/user-data/outputs/Screen4.jsx` - use this version.

---

## FILES SUMMARY

### New Files to Create:
1. `src/components/RivalrySummaryScreen.jsx` - Complete code provided above
2. `supabase/functions/summarize-rivalry/index.ts` - Complete code provided above

### Files to Modify:
1. `src/components/Screen4.jsx` - Use fixed version, add changes listed in Phase 5
2. `src/components/Screen6.jsx` - Update show numbering
3. `src/components/InterstitialScreen.jsx` - Update show numbering
4. `src/components/HowToPlayModal.jsx` - Add 21-show explanation
5. `index.html` or landing page - Update copy
6. `/supabase/functions/select-emcee-line/index.ts` - Add show 19/20/21 detection (optional optimization)

### Database Changes:
1. `rivalries` table - Run SQL from Phase 1
2. `emcee_lines` table - Run SQL from Phase 2

---

## ENVIRONMENT & CONFIGURATION

**Already configured in Supabase:**
- `SUPABASE_URL`: https://pqyiqqgohuxbiuhgpprw.supabase.co
- `SUPABASE_SERVICE_ROLE_KEY`: (in Supabase dashboard)
- `ANTHROPIC_API_KEY`: (in Supabase dashboard)

**No new environment variables needed.**

**Production URL:** oneupper.app (Vercel)

**Twilio:** SMS system built but disabled (awaiting A2P 10DLC)

---

## WHAT TO TELL NEW CHAT

Paste this entire document, then say:
```
I need to implement this fixed 21-show rivalry system for One-Upper.

The game is currently live at oneupper.app with infinite rivalries. 
All features work (AI judging, real-time sync, artifacts, brain boosts).

Please help me implement in this order:
1. Database migrations (SQL)
2. RivalrySummaryScreen.jsx component
3. summarize-rivalry Edge Function
4. Screen4.jsx modifications
5. Other component updates
6. Deployment

Let's start with the database migrations. Can you confirm the SQL 
statements from Phase 1 are correct and complete?

CONFIRMATION CHECKLIST
Before starting implementation:

[‚úÖ] All decisions finalized (no open questions)
[‚úÖ] Complete code provided for new components
[‚úÖ] All modifications specified for existing files
[‚úÖ] Database schema defined
[‚úÖ] Edge Function complete
[‚úÖ] Testing checklist comprehensive
[‚úÖ] Deployment sequence clear
[‚úÖ] Error handling documented
[‚úÖ] Cost analysis acceptable
[‚úÖ] Future flexibility preserved
[‚úÖ] Bug fix included


READY TO IMPLEMENT. NO BLOCKERS. ALL CODE PROVIDED.